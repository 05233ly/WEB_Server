Welcome to the Web-of-Python wiki!
# 三次握手--顶层抽象
首先，移除细节层面，让我们看看高度抽象层面是怎样的  
理解： 类比人与人的语言交流，交流实质内容之前，我首先得确认你的耳朵、声带是可以工作的，同样，对方也是这么想的。
## 三次握手
1. 第一次握手：客户端(client)发送，服务端收到，这样服务器说：客户端发、服务端收能力正常；
![一次握手](https://github.com/KissMyLady/Web-of-Python/blob/master/hand1.jpg)
2. 第二次握手：服务端(server)发送，客户端收到，这样客户端说：服务端收发， 客户端收发正常；
![二次握手](https://github.com/KissMyLady/Web-of-Python/blob/master/hand2.jpg)
3. 第三次握手：客户端(client)发送，服务端收到，这样服务端说，客户端收发， 服务端收发正常；
![三次握手](https://github.com/KissMyLady/Web-of-Python/blob/master/hand3.jpg)
   至此，双方都已经确认对方的收发没有问题，开始双方间数据(Data)传输; 

# 四次挥手--顶层抽象

时间：2019-11-6初稿；

目标：第一阶段：理解四次挥手是怎么回事， 具体细节日后添加；

内容：


     1、第一次挥手，客户端(clietn): 我不发数据了。 此时客户端内部：调用close关闭"发送通道"；


     2、第二次挥手，服务端(server): 我收到了。  此时服务端内部： recv_data = new_socket.rect() 解堵塞 
                                                                  if recv_data:
                                                                     do something
                                                                 else:
                                                            →→      new_socket.close()   ←←

     3、三次挥手，服务端(server): 我不发数据了。 此时 new_socket.close()；


     4、四次挥手，客户端(client): 我收到了。
![四次挥手](https://github.com/KissMyLady/Web-of-Python/blob/master/%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg)
***

说明： 1、socket是全双工通信，意味着可以同时收数据与发数据，所以收端口和发端口都要关闭才行；

结论： 1、谁先调用的close，谁就等待一段时间(有内置超时时间大约2分钟)，在这期间内，不允许这个端口重复使用；

常见面试题：
   **1、 为什么建立通信时是3次握手，而断开时是4次握手 ?**

  **标准答案**(答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。)
    
  **简单理解**(个人理解：三次握手时，服务器的收到和确认客户端的收、发能力可以合并，  四次挥手时，不能这样， 请看上图左下角说明)

   **2、 服务器最后一次调用close会直接关闭吗 ?**

   **不会**(个人理解： 当服务器最后一次执行close时，不会马上关闭，而是等待一个MSK时间， 之后才关闭。 因为服务器发出消息，"我不发了"), 客户端可能没有收到，可能延时， 所以客户端会再发一次"我收到了", 如果此时服务端关闭了，它没有接受这个信息的能力。 因此，服务器会保留这个端口MSK时间，直到收到客户端的"我收到了"。  最后，看下客户端， 客户端最后一次发出了"我收到了"给Server，服务端现它是在不会返回数据的，，导致一个问题，客户端怎么知道服务端收到没有？ 再发一个？ 那服务端再发， 客户端再发，依此，永远没有结束，永远都不知道对方收到否； 所以这个导致的问题， 我们就约定， 客户端发出信息"我收到了"后， 等待2MSL时间，期间：有数据，就发送"我收到了"，要是没数据返回，就直接释放客户端Client资源，结束通信。

   **3、 为什么客户端先调用close ?**

   谁先调用close，谁的资源就最后保留2分钟(垫后)， 在这两分钟期间内，不允许重复使用这个端口。这样，对于服务器来说，就是很严重的问题。
